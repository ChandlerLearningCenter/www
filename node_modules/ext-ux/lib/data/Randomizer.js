Ext.define('Ext.ux.data.Randomizer', {
    getInt: function (minValue, maxValue, probabilityNull) {
        return Math.floor((1 + maxValue - minValue) * Math.random()) + minValue;
    },
    getIntArray: function (minCount, maxCount, probabilityNull, minValue, maxValue, probValueNull) {
        var items, count, i;
        if (probabilityNull && this.getBoolean(probabilityNull)) {
            return null;
        }
        minValue = minValue || 0;
        maxValue = maxValue || 9;
        count = this.getInt(minCount, maxCount, probabilityNull);
        items = [];
        for (i = 0; i < count; i++) {
            items.push(this.getInt(minValue, maxValue, probValueNull));
        }
        return items;
    },
    getBoolean: function (probabilityTrue, probabilityNull) {
        if (probabilityNull && this.getBoolean(probabilityNull)) {
            return null;
        }
        if (probabilityTrue <= 0) {
            return false;
        }
        if (probabilityTrue >= 1) {
            return true;
        }
        return Math.random() <= probabilityTrue;
    },
    getAlphaNum: function (capitalization, includeIntegers, probabilityNull) {
        var possibleCount, randomInt;
        if (probabilityNull && this.getBoolean(probabilityNull)) {
            return null;
        }
        // to get a good random distribution, we need to know the exact number of possibilities 
        possibleCount = 0;
        switch (capitalization) {
        case 'capitalize':
        case 'uppercase':
        case 'lowercase':
            possibleCount = 26;
            break;
        case 'none':
            possibleCount = 52;
            break;
        }
        if (includeIntegers) {
            possibleCount += 10;
        }
        randomInt = this.getInt(0, possibleCount - 1);
        if (includeIntegers) {
            if (randomInt < 10) {
                return String.fromCharCode(48 + randomInt);
            } else {
                randomInt -= 10;
            }
        }
        if (capitalization === 'none') {
            // it could be either upper or lower 
            if (randomInt < 26) {
                capitalization = 'lowercase';
            } else {
                capitalization = 'uppercase';
                randomInt -= 26;
            }
        }
        switch (capitalization) {
        case 'capitalize':
        case 'uppercase':
            //return Convert.ToChar(65 + randomInt); 
            return String.fromCharCode(65 + randomInt);
        case 'lowercase':
            //return Convert.ToChar(97 + randomInt); 
            return String.fromCharCode(97 + randomInt);
        default:
            return '-';
        }
    },
    getWord: function (minLength, maxLength, capitalization, probabilityNull) {
        var builder, firstLetterTransform, subsequentLettersTransform, length, i;
        if (probabilityNull && this.getBoolean(probabilityNull)) {
            return null;
        }
        if (minLength < 0) {
            minLength = 0;
        }
        if (maxLength < minLength) {
            throw 'MaxLength cannot be less than MinLength.';
        }
        length = this.getInt(minLength, maxLength);
        if (length < 1) {
            return 'empty';
        }
        builder = '';
        switch (capitalization) {
        case 'uppercase':
            firstLetterTransform = 'uppercase';
            subsequentLettersTransform = 'lowercase';
            break;
        case 'lowercase':
            firstLetterTransform = 'lowercase';
            subsequentLettersTransform = 'lowercase';
            break;
        case 'capitalize':
            firstLetterTransform = 'uppercase';
            subsequentLettersTransform = 'lowercase';
            break;
        case 'none':
            firstLetterTransform = 'none';
            subsequentLettersTransform = 'none';
            break;
        default:
            firstLetterTransform = 'none';
            subsequentLettersTransform = 'none';
            break;
        }
        // first letter 
        builder += this.getAlphaNum(firstLetterTransform, false);
        // subsequent letters 
        for (i = 1; i < length; i++) {
            builder += this.getAlphaNum(subsequentLettersTransform, false);
        }
        return builder;
    },
    distributionFromRatios: function (ratio) {
        var i, totalProb, prob, targets, factor;
        // the array of probabilities acts as a distribution 
        // make sure they add up to 1. 
        totalProb = 0;
        for (i = 0; i < ratio.length; i++) {
            prob = ratio[i];
            if (prob < 0) {
                throw 'Probability must be greater than 0.';
            }
            totalProb += prob;
        }
        // probabilities will be adjusted so that all probabilities sum to 1. 
        targets = [];
        factor = 1.0 / totalProb;
        totalProb = 0;
        for (i = 0; i < ratio.length; i++) {
            prob = ratio[i];
            totalProb += prob;
            targets[i] = totalProb * factor;
        }
        return targets;
    },
    indexFromDistribution: function (distribution) {
        // need a random double 
        var i, rand = Math.random();
        // find the index within targets array 
        for (i = 0; i < distribution.length; i++) {
            if (distribution[i] > rand) {
                return i;
            }
        }
        return distribution.length - 1;
    },
    indexFromRatios: function (ratios, probabilityNull) {
        if (probabilityNull && this.getBoolean(probabilityNull)) {
            return null;
        }
        return this.indexFromDistribution(this.distributionFromRatios(ratios));
    },
    itemFromArray: function (arr, probRatio, probabilityNull) {
        if (probabilityNull && this.getBoolean(probabilityNull)) {
            return null;
        }
        var index;
        if (probRatio) {
            index = this.indexFromDistribution(this.distributionFromRatios(probRatio));
        } else {
            index = this.getInt(0, arr.length - 1);
        }
        return arr[index];
    },
    filteredItemFromArray: function (arr, filterFn, context) {
        var randItem, maxTries = (arr.length * 2),
            tries = 0;
        filterFn = filterFn ||
        function (arr, item) {
            return true;
        };
        while (tries < maxTries) {
            randItem = this.itemFromArray(arr);
            if (filterFn.call(context, arr, randItem) === true) {
                return randItem;
            }
            tries += 1;
        }
        return null;
    },
    otherItemFromArray: function (arr, item) {
        return this.filteredItemFromArray(arr, function (other) {
            return other !== item;
        });
    },
    getTitle: function (minWordCount, maxWordCount, minWordLength, maxWordLength, maxLength, probabilityNull) {
        var wordCount, builder, firstWordTransform, subsequentWordsTrasform, i;
        if (probabilityNull && this.getBoolean(probabilityNull)) {
            return null;
        }
        // get word count 
        wordCount = this.getInt(minWordCount, maxWordCount);
        if (wordCount === 0) {
            return String.Empty;
        }
        builder = '';
        firstWordTransform = 'capitalize';
        subsequentWordsTrasform = 'capitalize';
        // first word 
        builder += this.getWord(minWordLength, maxWordLength, firstWordTransform);
        // subsequent words 
        for (i = 1; i < wordCount; i++) {
            // throw in a comma 5% of the time 
            if (this.getBoolean(0.05)) {
                builder += ', ';
            } else {
                builder += ' ';
            }
            builder += this.getWord(minWordLength, maxWordLength, subsequentWordsTrasform);
        }
        if (maxLength && builder.length > maxLength) {
            builder = builder.substr(0, maxLength);
        }
        return builder;
    },
    getSentence: function (minWordCount, maxWordCount, minWordLength, maxWordLength, textTransform, probabilityNull) {
        var wordCount, builder, firstWordTransform, subsequentWordsTrasform, i;
        if (probabilityNull && this.getBoolean(probabilityNull)) {
            return null;
        }
        // get word count 
        wordCount = this.getInt(minWordCount, maxWordCount);
        if (wordCount === 0) {
            return '';
        }
        builder = '';
        switch (textTransform) {
        case 'lowercase':
            firstWordTransform = 'lowercase';
            subsequentWordsTrasform = 'lowercase';
            break;
        case 'uppercase':
            firstWordTransform = 'uppercase';
            subsequentWordsTrasform = 'uppercase';
            break;
        case 'capitalize':
            firstWordTransform = 'capitalize';
            subsequentWordsTrasform = 'capitalize';
            break;
        case 'capitalizeFirstWord':
            firstWordTransform = 'capitalize';
            subsequentWordsTrasform = 'lowercase';
            break;
        case 'none':
            firstWordTransform = 'none';
            subsequentWordsTrasform = 'none';
            break;
        default:
            firstWordTransform = 'none';
            subsequentWordsTrasform = 'none';
            break;
        }
        // first word 
        builder += this.getWord(minWordLength, maxWordLength, firstWordTransform);
        // subsequent words 
        for (i = 1; i < wordCount; i++) {
            // throw in a comma 10% of the time 
            if (this.getBoolean(0.10)) {
                builder += ', ';
            } else {
                builder += ' ';
            }
            builder += this.getWord(minWordLength, maxWordLength, subsequentWordsTrasform);
        }
        // punctuate 
        builder += '.';
        return builder;
    },
    getSentenceList: function (minSentenceCount, maxSentenceCount, minWordCount, maxWordCount, minWordLength, maxWordLength, textTransform, probabilityNull) {
        var i, sentenceCount, builder;
        if (probabilityNull && this.getBoolean(probabilityNull)) {
            return null;
        }
        // get sentence count 
        sentenceCount = this.getInt(minWordCount, maxWordCount);
        if (sentenceCount === 0) {
            return '';
        }
        builder = '';
        for (i = 0; i < sentenceCount; i++) {
            if (i > 0) {
                builder += '  ';
            }
            builder += this.getSentence(minWordCount, maxWordCount, minWordLength, maxWordLength, textTransform);
        }
        return builder;
    },
    getLoremIpsum: function (minLength, maxLength, probabilityNull) {
        var text;
        if (probabilityNull && this.getBoolean(probabilityNull)) {
            return null;
        }
        if (maxLength === 1) {
            return '.';
        } // since we always end with a period, just return it. 
        text = this.loremIpsum.substr(0, this.getInt(minLength, maxLength - 1)); // subtract 1 for the period 
        if (text && text.length) {
            text += '.';
        }
        return text;
    },
    loremIpsum: 'Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.',

    getStreetAddress: function (probabilityNull) {
        var result;
        if (probabilityNull && this.getBoolean(probabilityNull)) {
            return null;
        }
        // "7033 Louis Stephens Drive, Research Triangle Park, NC 27560"  
        result = '';
        result += this.getInt(25, 2500);
        result += ' ' + this.getTitle(1, 3, 5, 15, 0);
        result += ' ' + this.itemFromArray(['Street', 'Avenue', 'Road', 'Lane', 'St.', 'Ave.', 'Rd.', 'Ln.'], [1, 2, 4, 3, 2, 7, 3, 1], 0.10);

        result += ', ' + this.getTitle(1, 3, 5, 15, 0);
        result += ' ' + this.getTitle(1, 1, 2, 2, 0);
        result += '  ' + this.getInt(10000, 99999);
        return result;
    },
    getPhoneNumber: function (probabilityNull) {
        if (probabilityNull && this.getBoolean(probabilityNull)) {
            return null;
        }
        return "+1 (1)919 994 5922";
    },
    getTokens: function (delimiter, minTokenCount, maxTokenCount, minTokenLength, maxTokenLength, capitalization, probabilityNull) {
        var result, i, tokenCount = this.getInt(minTokenCount, maxTokenCount);
        if (probabilityNull && this.getBoolean(probabilityNull)) {
            return null;
        }
        result = '';
        for (i = 0; i < tokenCount; i++) {
            result += (result ? delimiter : '');
            result += this.getWord(minTokenLength, maxTokenLength, capitalization, 0);
        }
        return result;
    },
    getEmailAddress: function (probabilityInvalid, capitalization, probabilityNull) {
        var result, probabilityValid, probabilityValidToken, isValid;
        if (probabilityNull && this.getBoolean(probabilityNull)) {
            return null;
        }
        probabilityInvalid = probabilityInvalid || 0;
        probabilityValid = 1 - probabilityInvalid;
        probabilityValidToken = Math.pow(probabilityValid, (1 / 3));

        isValid = true;
        result = '';
        if (this.getBoolean(probabilityValidToken)) {
            result += this.getTokens('.', 1, 2, 3, 12, capitalization, 0);
        } else {
            isValid = false;
        }
        if (this.getBoolean(probabilityValidToken)) {
            result += '@';
            result += this.getTokens('.', 1, 2, 5, 8, capitalization, 0);
        } else {
            isValid = false;
        }
        if (this.getBoolean(probabilityValidToken)) {
            result += '.';
            result += this.itemFromArray(['com', 'net', 'gov', 'cs'], [10, 3, 1, 1], 0);
        } else {
            isValid = false;
        }
        return result;
    },
    getIntID: function (minValue, maxValue, probabilityNull) {
        var id, candidateID, attemptCount;
        this.intIDLookup = this.intIDLookup || {};
        this.intIDCount = this.intIDCount || 0;
        minValue = minValue || 1;
        maxValue = maxValue || 100000000;
        // like getInt except that it guarantees unique 
        attemptCount = 1;
        while (!id && attemptCount < 20) {
            candidateID = this.getInt(minValue, maxValue, probabilityNull);
            if (this.intIDLookup[candidateID]) {
                attemptCount += 1;
            } else {
                id = candidateID;
                this.intIDLookup[id] = true;
                this.intIDCount += 1;
                return id;
            }
        }
        return null;
    },


    /*
    getGraph: function(params){

        var populateNodeFn, minNodeCount, maxNodeCount, minChildCount, maxChildCount, minParentCount, maxParentCount, referenceParents, rooted, childrenParam, parentsParam, me = this, nodeCount, i, node, nodes, rootNode, otherCount, allowMultipleChildren, allowMultipleParents, emptyFn;

        params = params || {};
        populateNodeFn = params.populateNodeFn || params.populateNode || params.populate;
        minNodeCount = params.minNodeCount || params.minNodes; 
        maxNodeCount = params.maxNodeCount || params.maxNodes; 
        minChildCount = params.minChildCount || params.minChildren; 
        maxChildCount = params.maxChildCount || params.maxChildren; 
        minParentCount = params.minParentCount || params.minParents; 
        maxParentCount = params.maxParentCount || params.maxParents; 
        referenceParents = params.referenceParents || params.parents; 
        rooted = params.rooted; 
        childrenParam = params.childrenParam || params.childParam; 
        parentsParam = params.parentsParam || params.parentParam;


        // set defaults
        minNodeCount = minNodeCount || 0;
        maxNodeCount = maxNodeCount || 10;
        minChildCount = minChildCount || 0;
        maxChildCount = maxChildCount || 1;
        minParentCount = minParentCount || 0;
        maxParentCount = maxParentCount || 1;
        
        
        referenceParents = referenceParents === true;   // defaults to false
        rooted = rooted !== false;      // defaults to true

        // fix any inconsistencies in count constraints
        maxNodeCount = maxNodeCount >= minNodeCount ? maxNodeCount : minNodeCount;
        maxChildCount = maxChildCount >= minChildCount ? maxChildCount : minChildCount;
        maxParentCount = maxParentCount >= minParentCount ? maxParentCount : minParentCount;

        // how many nodes?
        nodeCount = this.getInt(minNodeCount, maxNodeCount);
        if(nodeCount < 1){ return null; }
        otherCount = nodeCount - 1;
 
        // fix any inconsistencies in count constraints based on actual node count
        minChildCount = minChildCount < otherCount ? minChildCount : otherCount;
        maxChildCount = maxChildCount < otherCount ? maxChildCount : otherCount;
        minParentCount = minParentCount < otherCount ? minParentCount : otherCount;
        maxParentCount = maxParentCount < otherCount ? maxParentCount : otherCount;

        // helpers
        allowMultipleChildren = maxChildCount > 1;
        allowMultipleParents = maxParentCount > 1;

        if(referenceParents && !parentsParam){
            parentsParam = allowMultipleParents ? 'parents' : 'parent';
        }
        if(!childrenParam){
            childrenParam = allowMultipleChildren ? 'children' : 'child';
        }


        emptyFn = undefined;

     
        
        function addLink(parent, child){
            if(parent && child){
                parent._children().push(child);
                child._parents().push(parent);
            }
        }

        function addLinks(node, arr, i){
            var other;
            // add parents
            while(node.getParentCount() < node._finalParentCount()){
                other = me.filteredItemFromArray(arr, function(arr2, item){
                    return item.getIsAvailableParent(node);
                });
                if(!other){ break; }
                addLink(other, node);
            }
            // add children
            while(node.getChildCount() < node._finalChildCount()){
                other = me.filteredItemFromArray(arr, function(arr2, item){
                    return item.getIsAvailableChild(node);
                });
                if(!other){ break; }
                addLink(node, other);
            }
        }
        
        function finalizeNode(node){
            if(allowMultipleChildren){
                node[childrenParam] = node._children();
            }else{
                node[childrenParam] = node._children().length ? node._children()[0]: null;
            }
            if(referenceParents){
                if(allowMultipleParents){
                    node[parentsParam] = node._parents();
                }else{
                    node[parentsParam] = node._parents().length ? node._parents()[0]: null;
                }
            }
            

        }

        function Node(i){    

            var _index = i;
            var _finalParentCount = me.getInt(minParentCount, maxParentCount);
            var _finalChildCount = me.getInt(minChildCount, maxChildCount);
            var _parents = [];
            var _children = [];

            this._index = function(){ return _index; };
            this._finalParentCount = function(){ return _finalParentCount; };
            this._finalChildCount = function(){ return _finalChildCount; };
            this._parents = function(){ return _parents; };
            this._children = function(){ return _children; };
        }
        Node.prototype = {
            getIsAvailableParent: function(child){
                return this !== child && this._finalChildCount() > this._children().length;
            },
            getIsAvailableChild: function(parent){
                if(rooted && this._index() === 0){ return false; }
                return this !== parent && this._finalParentCount() > this._parents().length;
            },
            getParentCount: function(){
                return this._parents().length;
            },
            getChildCount: function(){
                return this._children().length;
            }
        };

        // create nodes
        nodes = [];
        for(i=0;i<nodeCount;i++){
            nodes.push(new Node(i));
        }

        // add links
        for(i=0;i<nodes.length;i++){
            node = nodes[i];
            addLinks(node, nodes, i);
        }

        // set the root
        rootNode = nodes[0];

        // populate
        if(populateNodeFn){
            for(i=0;i<nodes.length;i++){
                node = nodes[i];
                populateNodeFn(node, nodes, rootNode);
            }
        }

        // finalize
        for(i=0;i<nodes.length;i++){
            node = nodes[i];
            finalizeNode(node);
        }
        
        // let's see if sjs is working
        //hold(5000);

        return {
            root: rootNode,
            nodes: nodes
        };
    },
    */

    the: 'end'
});
// aliases 
Ext.apply(Ext.ux.data.Randomizer.prototype, {
    getLatin: Ext.ux.data.Randomizer.prototype.getLoremIpsum,
    getLatinText: Ext.ux.data.Randomizer.prototype.getLoremIpsum
});