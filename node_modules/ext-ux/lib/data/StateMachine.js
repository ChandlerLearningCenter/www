/*global */

Ext.define('Ext.ux.data.StateMachine', {

    constructor: function (config, scp) {
        var me = this, serializer, stateGraph, stateLookup, currentState, initialState, errorState, item, k, next, errorMessage,       
            NEXT = 'trans';

        // the config becomes our graph, so make sure it is all there
        config = config || {};
        config.state = config.state || {}; // this becomes the lookup, so we need an object
        // hydrate the config object
        serializer = new Ext.ux.data.Serializer();
        
        // the following allows us to pass the function name as a string in the config
        function resolveEventHandler(obj, eventName){
            var fn = obj[eventName], fname,
                scope = obj.scope || config.scope || scp || me;
            if(fn){
                if(Ext.isString(fn)){
                    fname = fn;
                    fn = scope[fname];
                    if(!fn){ throw 'Cannot resolve ' + fname; }
                    // wrap the function
                    obj[eventName] = function(){ return fn.apply(scope, arguments); };
                }else{
                    if(Ext.isFunction(fn)){
                        if(scope !== me){
                            // wrap the function
                            obj[eventName] = function(){ return fn.apply(scope, arguments); };
                        }
                    }else{
                        throw 'invalid event handler';
                    }
                }
            }
        }
  
        // copy and resolve event handlers
        this.beforeChange = config.beforeChange;
        this.afterChange = config.afterChange;
        resolveEventHandler(this, 'beforeChange');
        resolveEventHandler(this, 'afterChange');
    
        // hydrate graph
        stateGraph = serializer.hydrate(config, true, true, true);
        stateLookup = stateGraph.state;

        // make sure there is an initial state and an error state
        initialState = stateGraph.initial;
        if (!initialState) {
            // create an initial state 
            next = {};
            initialState = {};
            initialState[NEXT] = next;
            // point it to all other states
            for (k in stateLookup) {
                if (stateLookup.hasOwnProperty(k)) {
                    item = stateLookup[k];
                    next[k] = item; // add reference
                }
            }
            stateGraph.initial = initialState;
        }

        // check for error state
        errorState = stateGraph.error || {};
        
        // the states should all know their name.  doing it this way guarantees uniqueness.
        for (k in stateLookup) {
            if (stateLookup.hasOwnProperty(k)) {
                item = stateLookup[k];
                if(Ext.isObject(item)){
                    item.name = k; // it should know its name
                    item[NEXT] = (item[NEXT] || {});    // make sure there is a next           
                    // resolve event handlers
                    resolveEventHandler(item, 'beforeExit');
                    resolveEventHandler(item, 'afterExit');
                    resolveEventHandler(item, 'beforeEnter');
                    resolveEventHandler(item, 'afterEnter');
                }
            }
        }
        
        // goto initial state
        currentState = initialState;
       
        // public methods.  they can be synchronous.
        Ext.apply(this, {
            getCurrentState: function () {
                return currentState ? currentState.name : undefined;
            },
            gotoState: function (name) {
                var next, nextState, exitState;
                if (currentState) {
                    next = currentState[NEXT];
                    if(next){
                        nextState = next[name];
                        if (nextState) { 
                            
                            exitState = currentState;
                            
                            // handle before callbacks
                            if(me.beforeChange && me.beforeChange(nextState.name, exitState.name, me) === false){
                                return false;
                            }
                            if(exitState.beforeExit && exitState.beforeExit(nextState.name, exitState.name, me) === false){
                                return false;
                            }      
                            if(nextState.beforeEnter && nextState.beforeEnter(nextState.name, exitState.name, me) === false){
                                return false;
                            }      
                            
                            // okay, make the change
                            currentState = nextState;  
                            
                            // handle after callbacks
                            if(exitState.afterExit){
                                exitState.afterExit(nextState.name, exitState.name, me);
                            }
                            if(nextState.afterEnter){
                                nextState.afterEnter(nextState.name, exitState.name, me);
                            }
                            if(me.afterChange){
                                me.afterChange(nextState.name, exitState.name, me);
                            }
                            return true;  
                        } else {
                            return false;
                        }
                    }else{
                        return false;
                    }
                }else{
                    return false;
                }
            },
            gotoNext: function(){
                var next, key, first;
                // this assumes we want to go to the first state in the list
                 if (currentState) {
                    next = currentState[NEXT];
                    if(next){
                        for(key in next){
                            if(next.hasOwnProperty(key)){
                                if(Ext.isObject(next[key])){
                                    first = key;
                                    break;
                                }
                            }
                        }
                        if(first){
                            return me.gotoState(first);
                        }
                    }
                 }
                 return false;
            },
            isCurrentState: function(name){
                return currentState && (currentState.name === name);
            },
            isValidState: function(name){
                return stateLookup[name] ? true : false;
            },
            isValidNextState: function(name){
                return (currentState && (currentState[NEXT])[name]) ? true : false;
            },       
            isInitialState: function(){
                return currentState === initialState;
            },
            isErrorState: function(){
                return errorState && (currentState === errorState);
            }, 
            getErrorMessage: function(){
                if(this.isErrorState()){
                    return errorMessage;
                }
            },
            getNextStates: function(){
                var k, next, list, nextState;
                // return an array of strings.  memoize.
                if(currentState){
                    if(!currentState.nextList){
                        next = currentState[NEXT];
                        list = [];
                        if(next){
                            for(k in next){
                                if(next.hasOwnProperty(k)){
                                    nextState = next[k];
                                    if(Ext.isObject(nextState)){
                                        list.push(next[k]);
                                    }
                                }
                            }
                        }
                        currentState.nextList = list;
                    }
                    return currentState.nextList;
                }
            }
        });
        
        return this;
    },

    the: 'end'
});