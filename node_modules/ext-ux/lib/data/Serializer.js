Ext.define('Ext.ux.data.Serializer', {
    oidProp: 'oid',
    refProp: 'ref',
    getOidFnName: 'getOID',
    mergeProp: 'merge',

    deserialize: function (text, hydrate, enableRefShorthand, genOIDs) {
        if (hydrate) {
            return this.hydrate(Ext.decode(text), true, enableRefShorthand, genOIDs); // no harm doing it inplace since they are all new objects
        } else {
            return Ext.decode(text);
        }
    },
    hydrate: function (item, hydrateInPlace, enableRefShorthand, genOIDs) {
        var hydrator, mergeQueue, oid, referencedInstance, i, referenceInstance;
        if (!item) {
            return null;
        }
        if (!hydrateInPlace) {
            item = this.clone(item); 
        }
        item = this.handleShorthand(item, enableRefShorthand, genOIDs);
        if (!this.fixExistingOIDs(item)) {
            return null;
        }
        hydrator = this.newHydrator(item);
        if (hydrator.hasMultiples) {
            throw 'We should not have a cyclical graph.';
        }
        mergeQueue = [];
        // hydrate
        for (oid in hydrator.referencedInstanceLookup) {
            if (hydrator.referencedInstanceLookup.hasOwnProperty(oid)) {
                referencedInstance = hydrator.referencedInstanceLookup[oid];
                if (referencedInstance.references && referencedInstance.references.length) {
                    for (i = 0; i < referencedInstance.references.length; i++) {
                        referenceInstance = referencedInstance.references[i];
                        this.removeReference(referenceInstance, referencedInstance, mergeQueue);
                    }
                }
            }
        }
        // do the merges last
        for (i = 0; i < mergeQueue.length; i++) {
            this.mergeItem(mergeQueue[i].target, mergeQueue[i].source);
        }
        return item;
    },


    fixExistingOIDs: function (item) {
        var objectList, existingOIDs, obj, oid, i;
        // first, traverse the object to look for any specified oids
        // these need to be moved into a function for preservation 
        objectList = this.getUniqueObjectList(item);
        if (objectList && objectList.length) {
            existingOIDs = {};
            for (i = 0; i < objectList.length; i++) {
                obj = objectList[i];
                oid = obj[this.oidProp];
                if (oid) {
                    if (existingOIDs[oid]) {
                        throw 'Duplicated OIDs: ' + oid;
                    }
                    existingOIDs[oid] = obj;
                    this.fixExistingOID(obj, oid);
                }
            }
        }
        return true;
    },
    fixExistingOID: function (obj, oid) {
        if (!obj || !oid) {
            return;
        }
        if (!obj[this.getOidFnName]) {
            obj[this.getOidFnName] = function () {
                return oid;
            };
        }
    },

    clone: function (item) {
        var cloneMap, clone;
        // since we hydrate and dehydrate in place, we may need a clone
        cloneMap = new Ext.ux.data.CloneMap(item);
        clone = cloneMap.getCloneRoot();
        return clone;
    },

    serialize: function (item, dehydrate, dehydrateInPlace) {
        if (dehydrate) {
            return Ext.encode(this.dehydrate(item, dehydrateInPlace));
        } else {
            return Ext.encode(item);
        }
    },
    dehydrate: function (item, dehydrateInPlace) {
        var dehydrator, i, meta, preferredIndex, preferredInstance, j;
        if (!item) {
            return null;
        }
        if (!dehydrateInPlace) {
            item = this.clone(item);
        }

        if (!this.fixExistingOIDs(item)) {
            return null;
        }

        dehydrator = this.newHydrator(item);
        if (!dehydrator.hasMultiples) {
            return item;
        }

        // loop thru the multiples.  for each multiple instance set, there can be only one
        for (i = 0; i < dehydrator.multipleInstanceMetas.length; i++) {
            meta = dehydrator.multipleInstanceMetas[i];
            preferredIndex = this.getPreferredInstanceIndex(meta);
            preferredInstance = meta.instances[preferredIndex];
            this.setPreferredInstanceOID(preferredInstance);
            for (j = 0; j < preferredIndex; j++) {
                this.addReference(meta.instances[j], preferredInstance);
            }
            for (j = preferredIndex + 1; j < meta.instances.length; j++) {
                this.addReference(meta.instances[j], preferredInstance);
            }
        }

        return item;
    },

    addReference: function (instance, preferredInstance) {
        var reference, parentInstance;
        reference = {};
        // set the ref property value to the OID from the meta
        reference[this.refProp] = instance.meta.oid;

        // must have a parentInstance
        if (!instance.parent) {
            throw 'Cannot swap out an instance without a parent instance.';
        }
        parentInstance = instance.parent;

        // do the swap.  how we do this depends on the specifics of the instance and its parent
        parentInstance.meta.item[instance.rel] = reference;

    },

    removeReference: function (referenceInstance, preferredInstance, mergeQueue) {
        var parentInstance;
        // must have a parentInstance
        if (!referenceInstance.parent) {
            throw 'Cannot swap out a reference instance without a parent instance.';
        }
        parentInstance = referenceInstance.parent;

        // do the swap.  how we do this depends on the specifics of the instance and its parent
        parentInstance.meta.item[referenceInstance.rel] = preferredInstance.meta.item;

        if (referenceInstance.meta.item.merge) {
            mergeQueue.push({
                target: preferredInstance.meta.item,
                source: referenceInstance.meta.item.merge
            });
        }
    },

    mergeItem: function (target, source) {
        var key;
        if (!source) {
            return target;
        }
        if (!target) {
            return source;
        }
        if (Ext.isArray(target)) {
            if (Ext.isArray(source)) {
                return target.concat(source);
            } else {
                throw 'merge mismatch.  array and non-array.';
            }
        } else if (Ext.isObject(target)) {
            if (!source) {
                return target.splice(0, 0);
            }
            if (Ext.isObject(source)) {
                for (key in source) {
                    if (source.hasOwnProperty(key)) {
                        if (key !== Ext.ux.data.ObjectMap.getMetaFnName) { // skip the meta function  
                            target[key] = this.mergeItem(target[key], source[key]);
                        }
                    }
                }
                return target;
            } else {
                throw 'merge mismatch.  object and non-object.';
            }
        } else {
            return source;
        }
    },


    // override as needed
    setPreferredInstanceOID: function (instance) {
        var oid;

        if (instance.meta.item[this.getOidFnName]) {
            oid = instance.meta.item[this.getOidFnName]();
        } else {
            oid = instance.meta.item[this.oidProp];
        }

        if (!oid) {
            // generate an oid
            // note: this function does not care about the instance, but an overriding function could.
            if (!this.nextOID) {
                this.nextOID = 1;
            }
            oid = this.nextOID;
            // increment for next time
            this.nextOID += 1;
        }
        // add to the meta
        instance.meta.oid = oid;

        // set appropriate property to the oid
        if (instance.meta.isObject) {
            // easily done for an object
            instance.meta.item[this.oidProp] = instance.meta.oid;
        } else if (instance.meta.isArray) {
            // todo, how do we set the OID property for an array?
            throw 'need to work out how the oid is set for an array.';
        }
    },

    // this function is split out with an eye towards overriding it
    getPreferredInstanceIndex: function (meta) {
        // by default, just return the first encountered.
        // however, we could sort them by depth or in some other way
        return 0;
    },

    newHydrator: function (item) {
        var hydrator;
        hydrator = new Ext.ux.data.Hydrator({
            oidProp: this.oidProp,
            refProp: this.refProp,
            getOidFnName: this.getOidFnName,
            mergeProp: this.mergeProp
        });
        // add the given item
        hydrator.add(item);
        return hydrator;
    },

    getObjectLookup: function () {
        return new Ext.ux.data.ObjectMap();
    },

    getUniqueObjectList: function (item) {
        var list, lookup;
        list = [];
        lookup = this.getObjectLookup();
        this.appendToObjectList(list, lookup, item);
        return list;
    },
    appendToObjectList: function (list, lookup, item) {
        var isArray, isObject, i, key;
        if (!item) {
            return;
        }
        if (Ext.isFunction(item)) {
            return;
        }
        if (lookup.containsKey(item)) {
            return;
        }
        isArray = Ext.isArray(item);
        isObject = (isArray ? false : Ext.isObject(item));
        if (isArray || isObject) {
            lookup.add(item, true);
            if (isArray) {
                for (i = 0; i < item.length; i++) {
                    this.appendToObjectList(list, lookup, item[i]);
                }
            } else {
                list.push(item);
                for (key in item) {
                    if (item.hasOwnProperty(key)) {
                        this.appendToObjectList(list, lookup, item[key]);
                    }
                }
            }
        }
    },

    handleShorthand: function (obj, enableRefShorthand, genOIDs, defaultRootOID) {
        var oidDelimiter, oidProp, refProp, mergeProp, refStringPrefix, getRef, checkItem;
        if (!obj || (!Ext.isObject(obj) && !Ext.isArray(obj))) {
            return obj;
        }
        oidDelimiter = '.';
        enableRefShorthand = (enableRefShorthand !== false);
        genOIDs = (genOIDs === true);
        if (!enableRefShorthand && !genOIDs) {
            return obj;
        }
        oidProp = this.oidProp;
        refProp = this.refProp;
        mergeProp = this.mergeProp;
        defaultRootOID = defaultRootOID || '';
        refStringPrefix = refProp + ':';
        getRef = function (str) {
            if (str.length > refStringPrefix.length && str.substr(0, refStringPrefix.length) === refStringPrefix) {
                return str.substr(refStringPrefix.length);
            } else {
                return null;
            }
        };
        checkItem = function (item, rootOID, doRefShorthand, doGenOIDs, parent, parentIsArray, rel) {
            var i, key, refKey, refObj;
            if (!item) {
                return;
            }
            if (Ext.isArray(item)) {
                if (doGenOIDs && rootOID) {
                    rootOID += oidDelimiter;
                }
                for (i = 0; i < item.length; i++) {
                    checkItem(item[i], rootOID + i, doRefShorthand, doGenOIDs, item, true, i);
                }
            } else if (Ext.isObject(item)) {
                if (doGenOIDs) {
                    if (item[oidProp]) {
                        rootOID = item[oidProp];
                    } else if (item[refProp]) {
                        rootOID = item[refProp];
                    } else {
                        // generate the oid
                        item[oidProp] = rootOID;
                    }
                    // add delimiter
                    if (rootOID) {
                        rootOID += oidDelimiter;
                    }
                }
                // recurse
                if (item[refProp]) {
                    // this is a ref object.  we only recurse through the merge object if it exists
                    if (item[mergeProp]) {
                        // we don't want the merge object to get an OID
                        for (key in item[mergeProp]) {
                            if (item[mergeProp].hasOwnProperty(key)) {
                                checkItem(item[mergeProp][key], rootOID + key, doRefShorthand, false, item[mergeProp], false, key);
                            }
                        }
                    }
                } else {
                    for (key in item) {
                        if (item.hasOwnProperty(key)) {
                            checkItem(item[key], rootOID + key, doRefShorthand, doGenOIDs, item, false, key);
                        }
                    }
                }
            } else if (doRefShorthand && Ext.isString(item)) {
                refKey = getRef(item);
                if (refKey) {
                    // replace the string with an obj
                    refObj = {};
                    refObj[refProp] = refKey;
                    parent[rel] = refObj;
                }
            }
        };
        checkItem(obj, defaultRootOID, enableRefShorthand, genOIDs);
        return obj;
    }

});