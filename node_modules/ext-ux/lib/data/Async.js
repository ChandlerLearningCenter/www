Ext.define('Ext.ux.data.Async', {

    singleton: true,


    isArray: function(obj){
        return Object.prototype.toString.apply(obj) === '[object Array]';
    },
    isFunction: function(obj){
        return Object.prototype.toString.apply(obj) === '[object Function]';
    },

    handleSuccess: function(o){
        if(o && o.success){
            if(arguments.length <= 1){
                o.success.call(o.scope || this);
            }else{
                o.success.apply(o.scope || this, Array.prototype.slice.call(arguments, 1));
            }
        }
    },
    handleFailure: function(o){
        if(o && o.failure){
            if(arguments.length <= 1){
                o.failure.call(o.scope || this);
            }else{
                o.failure.apply(o.scope || this, Array.prototype.slice.call(arguments, 1));
            }
        }
    }, 
    
    
    pass: function(o, fn, scope, params, success, failure){
        fn.call(scope, {
            params:     params ||   o.params,
            success:    success ||  o.success,
            failure:    failure ||  o.failure,
            scope:      scope ||    o.scope
        });
    },
    
    /*
    passParams: function(o, fn, params, scope){
        fn.call(scope, {
            params: params || o.params,
            success: o.success,
            failure: o.failure,
            scope: o.scope
        });
    },
    passSuccess: function(o, fn, success, params){
        fn({
            params: params || o.params,
            success: success,
            failure: o.failure,
            scope: o.scope
        });
    },
    */

    apply: function(o1, o2){
        var key;
        if(o2){
            for(key in o2){
                if(o2.hasOwnProperty(key)){
                    o1[key] = o2[key];
                }
            }
        }
        return o1;
    },

    single: function (o) {
        var me = Ext.ux.data.Async,     // magically fixes any scoping issues
        fn, fnScope, params;
        if (!o.meta) {
            o.meta = {};
        }
        fn = o.params.fn;
        fnScope = o.params.scope || o.scope;
        params = o.params.params;
        if (Ext.isFunction(params)) {
            params = params.call(this, o);
        }
        if (fn) {
            fn.call(fnScope, {
                params: params,
                success: function (data) {
                    o.meta.data = data;
                    me.handleChildren(o, data);
                },
                failure: o.failure,
                scope: o.scope
            });
        } else {
            return me.handleChildren(o, null);
        }
    },
    handleChildren: function (o, parentData) {
        var me = Ext.ux.data.Async;     // magically fixes any scoping issues
        if (o.params.sequence) {
            return me.sequence({
                meta: {
                    parent: o
                },
                params: {
                    defaults: o.params,
                    items: o.params.sequence
                },
                success: function () {
                    me.handleSuccess(o, parentData);
                },
                failure: o.failure,
                scope: o.scope
            });
        } else if (o.params.parallel) {
            return me.parallel({
                meta: {
                    parent: o
                },
                params: {
                    defaults: o.params,
                    items: o.params.parallel
                },
                success: function () {
                    me.handleSuccess(o, parentData);
                },
                failure: o.failure,
                scope: o.scope
            });
        } else {
            return this.handleSuccess(o, parentData);
        }
    },

    sequence: function (o) {
        var me = Ext.ux.data.Async,     // magically fixes any scoping issues
        defaults, list, results, handleItemSuccess, lastO, peers, index, handleNextItem;
        if (!o.meta) {
            o.meta = {};
        }
        defaults = o.params.defaults || {};
        list = o.params.items;
        if (!list) {
            return this.handleSuccess(o);
        }
        if (!Ext.isArray(list)) {
            list = [list];
        } else {
            if (!list.length) {
                return this.handleSuccess(o);
            }
        }
        results = [];
        handleItemSuccess = function (data) {
            if(data){
                results[index] = data;
            }
            handleNextItem.call(this);
        };
        lastO = null;
        peers = [];
        index = -1;
        handleNextItem = function () {
            var item, fn, params, scope, nextO;

            index++;
            if (index >= list.length) {
                return me.handleSuccess(o, [results]);
            }
            item = list[index];

            if (!item || item.exclude) {
                return handleNextItem();
            }
            fn = item.fn || defaults.fn;
            params = item.params;
            scope = item.scope || defaults.scope || this;
            // handle the item
            nextO = {
                meta: {
                    mode: 'sequence',
                    parent: o.meta.parent,
                    peers: peers,
                    index: index,
                    previous: lastO
                },
                params: {
                    fn: fn,
                    params: params,
                    sequence: item.sequence,
                    parallel: item.parallel,
                    scope: scope
                },
                success: handleItemSuccess,
                failure: o.failure,
                scope: this
            };
            peers[index] = nextO;
            if (lastO) {
                lastO.next = nextO;
            }
            lastO = nextO;
            return me.single(nextO);
        };
        // start processing the items
        handleNextItem.call(this);
    },

    every: function(o){
        var params = o.params,
            fn = params.fn,
            scope = params.scope || this,
            items = params.items,
            defaults = params.defaults,
            getParams = params.getParams || function(item, defaults){ return Ext.apply({ item: item }, defaults); },
            sequenceItems, i, item, itemParams;
        if(items && items.length > 0) {
            sequenceItems = [];
            for(i=0; i<items.length; i++){
                item = items[i];
                itemParams = getParams(item, defaults);
                sequenceItems.push({
                    fn: fn,
                    scope: scope,
                    params: itemParams
                });
            }
            this.sequence({
                params: {
                    items: sequenceItems
                },
                success: o.success,
                failure: o.failure,
                scope: o.scope
            });
        } else {
            this.handleSuccess(o);
        }
    },

    parallel: function (o) {
        var me = Ext.ux.data.Async,     // magically fixes any scoping issues
            defaults, list, isDone, successCount, failureCount, totalCount, results, handleItemSuccess, handleItemFailure, lastO, peers, handleItem, i;
        if (!o.meta) {
            o.meta = {};
        }
        defaults = o.params.defaults || {};
        list = o.params.items;
        if (!list) {
            this.handleSuccess(o);
        }
        if (!Ext.isArray(list)) {
            list = [list];
        } else {
            if (!list.length) {
                this.handleSuccess(o);
            }
        }
        isDone = false;
        successCount = 0;
        failureCount = 0;
        totalCount = list.length;
        results = [];
        handleItemSuccess = function (index, data) {
            results[index] = data;
            successCount++;
            if (successCount === totalCount) {
                return me.handleSuccess(o, [results]);
            }
        };
        handleItemFailure = function (index, msg) {
            failureCount++;
            isDone = false;
            me.handleFailure(o, msg);
        };

        lastO = null;
        peers = [];

        //var index = -1;
        handleItem = function (index) {
            var item, fn, params, scope, nextO;
            if (isDone) {
                return;
            }
            item = list[index];
            fn = item.fn || defaults.fn;
            params = item.params;
            scope = item.scope || defaults.scope || this;
            // handle the item
            nextO = {
                meta: {
                    mode: 'parallel',
                    parent: o.meta.parent,
                    peers: peers,
                    index: index,
                    previous: lastO
                },
                params: {
                    fn: fn,
                    params: params,
                    sequence: item.sequence,
                    parallel: item.parallel,
                    scope: scope
                },
                success: function (data) {
                    handleItemSuccess.call(this, index, data);
                },
                failure: function (msg) {
                    handleItemFailure.call(this, index, msg);
                },
                scope: this
            };
            peers[index] = nextO;
            if (lastO) {
                lastO.next = nextO;
            }
            lastO = nextO;
            return me.single(nextO);
        };
        // start processing the items
        for (i = 0; i < list.length; i++) {
            handleItem.call(this, i);
        }
    },

    call: function (o) {
        this.single(o);
    }

});