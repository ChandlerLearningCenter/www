/*global setTimeout, clearTimeout, console */

// Same as StateMachine except some methods follow our standard async pattern.  
// This allows timeouts, ajax calls, etc. before or after state changes
Ext.define('Ext.ux.data.StateMachineAsync', {

    constructor: function (config, scp) {
        var me = this,
            serializer, stateGraph, stateLookup, currentState, initialState, errorState, item, k, next, errorMessage, NEXT = 'trans', isChangingState;

        // the config becomes our graph, so make sure it is all there
        config = config || {};
        config.state = config.state || {}; // this becomes the lookup, so we need an object
        // hydrate the config object
        serializer = new Ext.ux.data.Serializer();

        // the following allows us to pass the function name as a string in the config

        function resolveEventHandler(obj, eventName) {
            var fn = obj[eventName],
                fname, scope = obj.scope || config.scope || scp || me;
            if (fn) {
                if (Ext.isString(fn)) {
                    fname = fn;
                    fn = scope[fname];
                    if (!fn) {
                        throw 'Cannot resolve ' + fname;
                    }
                    // wrap the function
                    obj[eventName] = function () {
                        return fn.apply(scope, arguments);
                    };
                } else {
                    if (Ext.isFunction(fn)) {
                        if (scope !== me) {
                            // wrap the function
                            obj[eventName] = function () {
                                return fn.apply(scope, arguments);
                            };
                        }
                    } else {
                        throw 'invalid event handler';
                    }
                }
            }
        }

        // copy and resolve event handlers
        this.delay = config.delay || this.delay;
        this.beforeChange = config.beforeChange || this.beforeChange;
        this.afterChange = config.afterChange || this.afterChange;
        resolveEventHandler(this, 'beforeChange');
        resolveEventHandler(this, 'afterChange');

        // hydrate graph
        stateGraph = serializer.hydrate(config, true, true, true);
        stateLookup = stateGraph.state;

        // make sure there is an initial state
        initialState = stateGraph.initial;
        if (!initialState) {
            // create an initial state 
            next = {};
            initialState = {};
            initialState[NEXT] = next;
            // point it to all other states
            for (k in stateLookup) {
                if (stateLookup.hasOwnProperty(k)) {
                    item = stateLookup[k];
                    next[k] = item; // add reference
                }
            }
            stateGraph.initial = initialState;
        }

        // check for error state
        errorState = stateGraph.error || {};

        // the states should all know their name.  doing it this way guarantees uniqueness.
        for (k in stateLookup) {
            if (stateLookup.hasOwnProperty(k)) {
                item = stateLookup[k];
                if (Ext.isObject(item)) {
                    item.name = k; // it should know its name
                    item[NEXT] = (item[NEXT] || {}); // make sure there is a next           
                    // resolve event handlers
                    resolveEventHandler(item, 'beforeExit');
                    resolveEventHandler(item, 'afterExit');
                    resolveEventHandler(item, 'beforeEnter');
                    resolveEventHandler(item, 'afterEnter');
                }
            }
        }

        // goto initial state
        currentState = initialState;



        // public methods.  they can be synchronous.
        Ext.apply(this, {
            getCurrentState: function () {
                return (currentState && currentState.name) ? currentState.name : undefined;
            },
            gotoState: function (o) {
                // allow to pass in a string and optional delay, but no callbacks will be handled
                if (Ext.isString(o)) {
                    return me.gotoState({
                        params: {
                            state: o
                        }
                    });
                }
                var params = o.params,
                    name = params.state,
                    allowFailure = params.allowFailure === true || this.config.allowFailure === true || this.allowFailure === true,
                    onFailure,onSuccess,
                    next, nextState, exitState, eventParams, delay;
                
                onFailure = function(msg){
                    isChangingState = false;
                    if(allowFailure){
                        me.handleSuccess(o, false);
                    }else{
                        me.handleFailure(o, msg);
                    }  
                };
                
                onSuccess = function(){
                    isChangingState = false;
                    me.handleSuccess(o, true);
                };
                
                if(isChangingState){ return onFailure('already changing state'); }
                isChangingState = true;
                
                //if(currentState && currentState.name === name){ return onFailure('already at state: ' + name); }
                
                function handleEvent(o) {
                    var params = o.params,
                        spawn = params.spawn === true,
                        eventParams = params.eventParams,
                        handler = params.handler;
                    if (handler) {
                        if (spawn) {
                            // we are not waiting to see if a failure occurs by the handler.  just handle the o now.
                            me.handleSuccess(o);
                            o = {};
                            handler({
                                params: eventParams,
                                success: o.success,
                                failure: o.failure,
                                scope: o.scope
                            });
                        }else{
                            // see if the handler fails.  if so, stop changing state.
                            handler({
                                params: eventParams,
                                success: o.success,
                                failure: function(msg){
                                    isChangingState = false;
                                    me.handleFailure(o, msg);
                                },
                                scope: o.scope
                            });   
                        } 
                    } else {
                        me.handleSuccess(o);
                    }
                }
                if (Ext.isDefined(currentState)) {
                    next = currentState[NEXT];
                    if (next) {
                        nextState = next[name];
                        if (nextState && nextState.name === name) {
                            // see if there is a delay passed in or in configuration
                            // todo, get first defined.  in other words, allow 0 to override other values.
                            delay = params.delay || next.delay || nextState.delay || me.delay;
                            exitState = currentState;
                            eventParams = {
                                newState: nextState.name,
                                oldState: exitState.name,
                                stateMachine: me
                            };
                            me.sequence({
                                params: {
                                    items: [{
                                        fn: function (o) {
                                            // make sure there is not an existing delay
                                            //if (me.delayTimeoutID) {
                                                // todo, we could add a queue to handle this case
                                                //return me.handleFailure('waiting for a delay');
                                            //}
                                            // handle delay if there is one
                                            if (delay && delay > 0) {
                                                me.delayTimeoutID = setTimeout(function () {
                                                    me.delayTimeoutID = null;
                                                    me.handleSuccess(o);
                                                },
                                                delay);
                                            } else {
                                                me.handleSuccess(o);
                                            }
                                        }
                                    },
                                    {
                                        fn: handleEvent,
                                        params: {
                                            eventParams: eventParams,
                                            handler: me.beforeChange // could be undefined
                                        }
                                    },
                                    {
                                        fn: handleEvent,
                                        params: {
                                            eventParams: eventParams,
                                            handler: exitState.beforeExit // could be undefined
                                        }
                                    },
                                    {
                                        fn: handleEvent,
                                        params: {
                                            eventParams: eventParams,
                                            handler: nextState.beforeEnter // could be undefined
                                        }
                                    },
                                    {
                                        fn: function (o) {
                                            // okay, make the change
                                            currentState = nextState;
                                            isChangingState = false;
                                            me.handleSuccess(o);
                                            // now handle any after events.  NOTE: o already handled
                                            me.sequence({
                                                params: {
                                                    items: [{
                                                        fn: handleEvent,
                                                        params: {
                                                            eventParams: eventParams,
                                                            spawn: true,
                                                            handler: exitState.afterExit // could be undefined
                                                        }
                                                    },
                                                    {
                                                        fn: handleEvent,
                                                        params: {
                                                            eventParams: eventParams,
                                                            spawn: true,
                                                            handler: nextState.afterEnter // could be undefined
                                                        }
                                                    },
                                                    {
                                                        fn: handleEvent,
                                                        params: {
                                                            eventParams: eventParams,
                                                            spawn: true,
                                                            handler: me.afterChange // could be undefined
                                                        }
                                                    }]
                                                }//,  NOTE: o already handled
                                                //success: o.success,
                                                //failure: onFailure,
                                                //scope: o.scope
                                            });
                                        }
                                    }]
                                },
                                success: onSuccess,     // final success
                                failure: onFailure
                            });
                        } else {
                            onFailure('invalid state 1: ' + name);
                        }
                    } else {
                        onFailure('invalid state 2: ' + name);
                    }
                } else {
                    onFailure('no current state');
                }
            },
            gotoNext: function (o) {
                var params, next, key, first;
                o = o || {};
                params = o.params || {};
                // this assumes we want to go to the first state in the list
                if (currentState) {
                    next = currentState[NEXT];
                    if (next) {
                        for (key in next) {
                            if (next.hasOwnProperty(key)) {
                                if (Ext.isObject(next[key])) {
                                    first = key;
                                    break;
                                }
                            }
                        }
                        if (first) {
                            me.gotoState({
                                params: {
                                    state: first,
                                    spawn: params.spawn,
                                    delay: params.delay,
                                    allowFailure: params.allowFailure
                                },
                                success: o.success,
                                failure: o.failure,
                                scope: o.scope
                            });
                        } else {
                            me.handleFailure(o, 'nothing next');
                        }
                    } else {
                        me.handleFailure(o, 'nothing next');
                    }
                } else {
                    me.handleFailure(o, 'no current state');
                }
            },
            cancelDelay: function(){
                if(this.delayTimeoutID){
                    clearTimeout(this.delayTimeoutID);
                    this.delayTimeoutID = null;
                }
            },
            gotoError: function (msg) {

            },
            isCurrentState: function (name) {
                return currentState && (currentState.name === name);
            },
            isValidState: function (name) {
                return stateLookup[name] ? true : false;
            },
            isValidNextState: function (name) {
                return (currentState && (currentState[NEXT])[name]) ? true : false;
            },
            isInitialState: function () {
                return currentState === initialState;
            },
            isErrorState: function () {
                return errorState && (currentState === errorState);
            },
            getErrorMessage: function () {
                if (this.isErrorState()) {
                    return errorMessage;
                }
            },
            getNextStates: function () {
                var k, next, list, nextState;
                // return an array of strings.  memoize.
                if (currentState) {
                    if (!currentState.nextList) {
                        next = currentState[NEXT];
                        list = [];
                        if (next) {
                            for (k in next) {
                                if (next.hasOwnProperty(k)) {
                                    nextState = next[k];
                                    if (Ext.isObject(nextState)) {
                                        list.push(next[k]);
                                    }
                                }
                            }
                        }
                        currentState.nextList = list;
                    }
                    return currentState.nextList;
                }
            }
        });
        return this;
    }
});