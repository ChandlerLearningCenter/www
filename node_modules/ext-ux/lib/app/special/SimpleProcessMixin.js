/*global console */

Ext.define('Ext.ux.app.special.SimpleProcessMixin', {
    extend: 'Ext.mixin.Mixin',

    mixinConfig: {
        id: 'simpleProcess'//,
        //hooks: {
        //    destroy: 'destroy'
        //}
    },
    
    //constructor: function(config) {
        //console.log('mixin constructor');
        //this.initConfig(config);
    //},
    
    //destroy: function() {
        // cleanup
    //},
    
    // this config just sets up manager classes to act as simple process state machine.
    // it gives them two states:  running and stopped
    
    
    // ASYNCHRONOUS STATE MACHINE CONFIG
    stateMachineConfig: {
        state: {
            initialized: {
                trans: {
                    running: 'ref:state.running',
                    stopped: 'ref:state.stopped'
                }
            },
            running: {
                trans: {
                    stopped: 'ref:state.stopped'
                } 
            },
            stopped: {
                trans: {
                    running: 'ref:state.running'
                }
            },
            error: {}
        },
        initial: 'ref:state.initialized',
        error: 'ref:state.error',
        afterChange: 'onChangeState',
        async: true
    },  
    
    
    /*
    initialize: function (o) {
        
        console.log('initialize simple process');
        
        //this.bind('start,stop,getState');
        //this.handleSuccess(o);      
        // check for autoStart   
        
        if (this.config && this.config.autoStart === true) {
            this.start(o);
        }else{
            if(this.autoStart === true){
                this.start(o);
            }else{
                this.handleSuccess(o);   
            }
        }
        
    },
    */
    
    
    // here we are calling function "gotoState" synchronously because 
    // this state machine is configured as SYNCHRONOUS
    start: function (o) {
        //this.handleSuccess(o);
        //this.gotoState('running');
        var me = this;
        o = o || {};
        this.gotoState({
            params: {
                state: 'running'
            },
            success: function () {
                me.handleSuccess(o, me.getCurrentState());
            },
            failure: o.failure,
            scope: o.scope
        });
    },
    stop: function (o) {
        //this.handleSuccess(o);
        //this.gotoState('stopped');
        var me = this;
        o = o || {};
        this.gotoState({
            params: {
                state: 'stopped'
            },
            success: function () {
                me.handleSuccess(o, me.getCurrentState());
            },
            failure: o.failure,
            scope: o.scope
        });
    },
    getState: function (o) {
        o = o || {};
        return this.handleSuccess(o, this.getCurrentState());
    },  
    onChangeState: function (newState) {
        //console.log('mixin ' + newState);
        switch (newState) {
        case 'running':
            this.isRunning = true;
            this.onRunning();
            break;
        default:
            this.isRunning = false;
            this.onStopped();
            break;
        }
    },
    
    onRunning: function(){
        // override this function as needed
        //console.log('base onRunning');
    },
    onStopped: function(){
        // override this function as needed
        //console.log('base onStopped');
    }
 

});
