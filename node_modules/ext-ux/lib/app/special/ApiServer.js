/*global console2, require */

Ext.define('Ext.ux.app.special.ApiServer', {
    extend: 'Ext.ux.app.Manager',

    initialize: function (o) {
        var me = this;
        //console.log('initialize api server');
        this.setupServer({
            params: o.params,
            success: function(){
                me.addRoutes(o);
            },
            failure: o.failure,
            scope: o.scope
        });
    },

    // override this method in child classes
    addRoutes: function (o) {
        //console.log('override addRoutes');
        this.handleSuccess(o);
    },

    // override this method in child classes
    /*setupServer: function(o){
        console.log('override setupServer');
        this.handleSuccess(o);
    },*/
    // override this method in child classes as needed
    setupServer: function (o) {
        // make sure there is a server to attach to
        var server = this.bus.server;
        if (!server) {
            return this.handleFailure(o, 'Api Server missing a valid server.');
        }
        this.server = server;
        this.handleSuccess(o);
    },
    
    
    
    apply: function(o1, o2){
        if(Ext.isObject(o2)){
            Ext.apply(o1, o2);
        }
        return o1;
    },

    routeAsync: function (path, fn, scope, options) {
        var me = this,
            serverFn, getParams, defaults, method, parseQuerystring;

        options = options || {};
        defaults = options.defaults;
        method = options.method || 'get';
        parseQuerystring = options.parseQuerystring === true;

        // handle special cases
        if (options.requireToken) {
            // this will setup the api function to require a one use token
            this.setupRequireToken(path, fn, scope, options);
            return;
        }

        getParams = function (req, res, next) {
            var params, incoming = req.params || {}, url;
            if (incoming) {   
                if (defaults) {       
                    // merge
                    params = me.apply(me.apply({},
                    defaults), incoming);
                } else {
                    params = incoming;
                }
            } else {
                if (defaults) {
                    params = defaults;
                }
            }          
            if(parseQuerystring){
                url = require('url').parse(req.url, true);
                me.apply(params, url.query);
            }          
            return params;
        };

        switch (method) {
        case 'get':
            serverFn = this.server[method];
            break;
        case 'post':
            serverFn = this.server[method];
            break;
        case 'del':
            serverFn = this.server[method];
            break;
        case 'put':
            serverFn = this.server[method];
            break;
        default:
            throw 'Unknown method: ' + method;
        }
        if (serverFn) {
            serverFn.call(this.server, path, function (req, res, next) {
                fn.call(scope, {
                    params: getParams(req, res, next),
                    success: function (data) {
                        res.send(data);
                        //next();
                    },
                    failure: function (msg) {
                        res.send({
                            error: true,
                            msg: msg
                        });
                        //next();
                    },
                    scope: me
                });
            });
        } else {
            throw 'no serverFn';
        }
    },

    setupRequireToken: function (path, fn, scope, options) {
        var me = this,
            ttl = options.ttl || 30000,
        // default to 30 seconds
        length = options.length || 4,
        // token length defaults to 4
        requireStopped = options.requireStopped === true,
            minToken = Math.pow(10, length - 1),
        // 1000,
        maxToken = Math.pow(10, length) - 1,
        //9999,
        getToken, checkTokenWrapper, token = null;
        scope = scope || this;
        getToken = function (o) {
            var randomizer, now = new Date(),
                str = '';
            if (token && token.getIsExpired()) {
                token = null;
            }
            // some functions should only be called when the process is stopped
            if (requireStopped && me.getManager('main').isRunning) {
                me.handleFailure(o, 'stop process before calling');
            } else {
                if (!token) {
                    randomizer = new Ext.ux.data.Randomizer();
                    token = {
                        ttl: ttl,
                        dateCreated: now,
                        token: (str + randomizer.getInt(minToken, maxToken).toString()),
                        getIsExpired: function () {
                            return ((now - this.dateCreated) > ttl);
                        }
                    };
                }
                me.handleSuccess(o, token);
            }
        };
        checkTokenWrapper = function (o) {
            var params = o.params,
                tokenValue = params.tokenValue;
            // check the token value
            if (tokenValue && token && token.token === tokenValue) {
                if (token.getIsExpired()) {
                    token = null;
                    me.handleFailure(o, 'expired token');
                } else {
                    // some functions should only be called when the process is stopped
                    if (requireStopped && me.getManager('main').isRunning) {
                        me.handleFailure(o, 'stop process before calling');
                    } else {
                        // ok to call the inner function
                        token = null;
                        fn.call(scope, o);
                    }
                }
            } else {
                me.handleFailure(o, 'invalid token ' + tokenValue);
            }
        };
        this.routeAsync(path, getToken, scope);
        this.routeAsync(path + '/:tokenValue', checkTokenWrapper, scope);
    },

    routeServer: function (server, path) {
        server.attachApiServer(this, path);
    },

    routeStatic: function (path, staticPath) {
        var express = require('express'),
            server = this.server;
        server.use(path, express['static'](staticPath));
    }

});