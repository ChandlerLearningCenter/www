/*global console, require */

Ext.define('Ext.ux.app.special.MySqlDataProvider', {
    extend: 'Ext.ux.app.Manager',

    /*
    // subclasses should implement a "call" configuration like the following
    
    calls: {
        doSomething: {
            type: 'routine',
            name: 'routine_name',
            args: 'id,text'
        },
        db: { <dbModel> }
    },
    
    */

    initialize: function (o) {
        this.setupCalls();
        this.getClient(o);
    },
    
    health: function (o) {
        var health = this.getDefaultHealth();
        if (!this.client) {
            health.status = 'missing mysql client';
        }
        this.handleSuccess(o);
    },

    getClient: function (o) {
        var mysql, client, me, config;
        if (this.client) {
            this.handleSuccess(o, this.client);
        } else {
            mysql = require('mysql');
            config = this.config; 
            client = mysql.createConnection(config);
            me = this;
            client.query('use ' + config.database, function (err) {
                if (err) {
                    me.handleFailure(o, err);
                } else {
                    me.client = client;
                    me.handleSuccess(o, client);
                }
            });
        }
    },
    
    callRoutine: function (o) {
        var params = o.params,
            name = params.name,
            args = params.args || '',
            data = params.data || {},
            i, key, value, sql;
        args = this.isString(args) ? args.split(',') : args;
        sql = "call " + name + "(";
        for (i = 0; i < args.length; i++) {
            key = args[i];
            value = data[key];
            if (i > 0) {
                sql += ',';
            }
            if (this.isEmpty(value)) {
                sql += 'NULL';
            } else {
                if (this.isString(value)) {
                    sql += "'" + value.replace("'", "\'") + "'";
                } else {
                    sql += value;
                }
            }
        }
        sql += ");";
        params.sql = sql;
        this.callSql(o);
    },

    callSql: function (o) {
        var me = this,
            logErrors = o.params.logErrors !== false,
            sql = o.params.sql;
        try{
            this.client.query(sql, function (err, results) { 
                if (err) {
                    if(logErrors){
                        console.log('sql error: ' + sql + ' -> ' + err);
                    }
                    me.handleFailure(o, err);
                } else {
                    me.handleSuccess(o, results);
                }
            });
        }
        catch(err){
            if(logErrors){
                console.log('caught sql error: ' + sql + ' -> ' + err);
            }
            me.handleFailure(o, err);
        }
    },  
    
    queryList: function (o) {
        var params = o.params,
            logErrors = params.logErrors,
            sql = params.sql;
        // get client object   
        this.getClient({
            success: function (client) {
                var me = this;
                // run query       
                client.query(sql, function (err, results, fields) {
                    if (err) {
                        if(logErrors){
                            console.log(sql);
                        }
                        me.handleFailure(o, err);
                    } else {
                        me.handleSuccess(o, results, fields);
                    }
                });
            },
            failure: o.failure,
            scope: this
        });
    },

    querySingle: function (o) {
        var params = o.params,
            sql = params.sql,
            logErrors = params.logErrors,
            allowMultiple = params.allowMultiple === true,
            // default to false
        allowNone = params.allowNone !== false; // default to true;
        // get client object
        this.getClient({
            success: function (client) {
                var me = this,
                    rowCount;
                // run query        
                client.query(sql, function (err, results, fields) {
                    if (err) {
                        if(logErrors){
                            console.log(sql);
                        }
                        me.handleFailure(o, err);
                    } else {
                        if (results) {
                            rowCount = results.length;
                            if (rowCount === 1) {
                                me.handleSuccess(o, results[0]);
                            } else {
                                if (rowCount === 0) {
                                    if (allowNone) {
                                        me.handleSuccess(o);
                                    } else {
                                        me.handleFailure(o, 'item not found');
                                    }
                                } else {
                                    if (allowMultiple) {
                                        me.handleSuccess(o, results[0]);
                                    } else {
                                        me.handleFailure(o, 'multiple items not allowed');
                                    }
                                }
                            }
                        } else {
                            me.handleSuccess(o);
                        }
                    }
                });
            },
            failure: o.failure,
            scope: this
        });
    },
    
    setupCalls: function () {
        var calls = this.calls || {},
            serializer = new Ext.ux.data.Serializer(),
            hydratedCalls,
            key;         
        // hydrate
        hydratedCalls = serializer.hydrate(calls, true, true, true);       
        // loop thru config items
        for (key in hydratedCalls) {
            if (hydratedCalls.hasOwnProperty(key) && key !== 'db') {
                this.setupCall(key, hydratedCalls[key]);
            }
        }
    },
    setupCall: function (name, config, target) {
        var me = this,
            fn, ns, key;
        target = target || this;
        if (config && Ext.isObject(config)) {
            if (config.type) {
                switch (config.type) {
                case 'routine':
                    fn = this.getMethod_routine(config);
                    break;             
                case 'upsertItem':
                    fn = this.getMethod_upsertItem(config);
                    break;
                case 'insertItem':
                    fn = this.getMethod_insertItem(config);
                    break;
                default:
                    fn = null;
                    break;
                }
                if (fn) {
                    target[name] = fn;
                }
            } else {
                // config is a namespace in this instance
                ns = {};
                for (key in config) {
                    if (config.hasOwnProperty(key)) {
                        me.setupCall(key, config[key], ns);
                    }
                }
                target[name] = ns;
            }
        }
    },
    
    getMethod_routine: function(config){
        var me = this;    
        return function (o) {
            var params = o.params || {};
            me.callRoutine({
                params: {
                    name: config.name,
                    args: config.args,
                    data: params.data || params.item || params.params
                },
                success: o.success,
                failure: o.failure,
                scope: o.scope
            });
        };
    },
     
    getMethod_upsertItem: function(config){
        var me = this,
            dedupe = config.dedupe;    
        return function (o) {
            var params = o.params || {},
            item = params.item,
            logErrors = params.logErrors,
            sql = me.getSql_upsertItem(config, item);  
            
            me.callSql({
                params: {
                    sql: sql,
                    logErrors: logErrors
                },
                success: function(results){   
                    var lookupValue;
                    if(results.insertId){
                        // inserted
                        me.handleSuccess(o, results.insertId, 1);
                    }else{
                        // updated
                        if(item.id){
                            me.handleSuccess(o, item.id, results.affectedRows);
                        }else{
                            if(dedupe){
                                // we need to do a select to find the id
                                lookupValue = item[dedupe.name];
                                me.querySingle({
                                    params: {
                                        sql: 'SELECT * FROM `' + config.table.name + '` WHERE `' + dedupe.name + '` = ' + me.sqlValue(lookupValue, dedupe) + ';'
                                    },
                                    success: function(row){
                                        me.handleSuccess(o, row.id, results.affectedRows);
                                    },
                                    failure: function(msg){
                                        // row updated, but this should not happen.  we don't know the id of the updated row
                                        me.handleSuccess(o, null, results.affectedRows);
                                    },
                                    scope: o.scope
                                });
                            }else{
                                // row updated, but this should not happen.  we don't know the id of the updated row
                                me.handleSuccess(o, null, results.affectedRows);
                            }   
                        }
                    }
                },
                failure: o.failure,
                scope: o.scope
            }); 
        };
    },
    
    getSql_upsertItem: function(config, item){
        var table = config.table,
            columns = table.columns,
            insertColumns = config.insertColumns || '?',
            updateColumns = config.updateColumns || '?',
            columnName, columnConfig, value, idColumn,
            insertMaps = [],
            updateMaps = [],
            i, map, builder;
            
        // todo, pull this from the config
        idColumn = 'id';
        
            
        if(insertColumns === '?' || insertColumns === '*'){
            for(columnName in columns){
                if(columns.hasOwnProperty(columnName)){
                    columnConfig = columns[columnName];
                    if(columnConfig && !columnConfig.identity && !columnConfig.autoIncrement){
                        value = item[columnName];       // assume property names are same as column names
                        if(insertColumns === '*' || !this.isEmpty(value)){     
                            insertMaps.push({
                                column: columnConfig,
                                value: value
                            });
                        } 
                    }
                }
            }
        }
        if(updateColumns === '?' || updateColumns === '*'){
            for(columnName in columns){
                if(columns.hasOwnProperty(columnName)){
                    columnConfig = columns[columnName];
                    if(columnConfig && !columnConfig.identity && !columnConfig.autoIncrement){
                        value = item[columnName];       // assume property names are same as column names
                        if(updateColumns === '*' || !this.isEmpty(value)){     
                            updateMaps.push({
                                column: columnConfig,
                                value: value
                            });
                        } 
                    }
                }
            }
        }    
        
        
        if(item[idColumn]){
            columnConfig = columns[idColumn];
            if(columnConfig && (columnConfig.identity || columnConfig.autoIncrement)){
                
                // just do an update.  no insert necessary
                builder = [];
                builder.push('UPDATE `');
                builder.push(table.name);
                builder.push('` set ');
                             
                for(i=0; i<updateMaps.length; i++){
                    map = updateMaps[i];
                    if(i>0){
                        builder.push(',');
                    }
                    builder.push('`');
                    builder.push(map.column.name);
                    builder.push('`');
                    builder.push(' = ');
                    builder.push(this.sqlValue(map.value, map.column.type, map.column.nullable, map.column.name));
                }
                builder.push(' WHERE `');
                builder.push(idColumn);
                builder.push('` = ');
                builder.push(item[idColumn]);
                builder.push(';');
            
            }else{
                throw 'cannot generate sql';
            }
        }else{
            
            // insert on duplicate key update

            // build sql
            builder = [];
            builder.push('INSERT INTO `');
            builder.push(table.name);
            builder.push('` (');
            for(i=0; i<insertMaps.length; i++){
                map = insertMaps[i];
                if(i>0){
                    builder.push(',');
                }
                builder.push('`');
                builder.push(map.column.name);
                builder.push('`');
            }
            builder.push(' ) VALUES ( ');      
            for(i=0; i<insertMaps.length; i++){
                map = insertMaps[i];
                if(i>0){
                    builder.push(',');
                }
                builder.push(this.sqlValue(map.value, map.column.type, map.column.nullable, map.column.name));
            }
            builder.push(' ) ON DUPLICATE KEY UPDATE ');
            for(i=0; i<updateMaps.length; i++){
                map = updateMaps[i];
                if(i>0){
                    builder.push(',');
                }
                builder.push('`');
                builder.push(map.column.name);
                builder.push('`');
                builder.push(' = ');
                builder.push(this.sqlValue(map.value, map.column.type, map.column.nullable, map.column.name));
            }
            builder.push(';');
        
        }
              
        return builder.join(''); 
    },
    
    
    
    
    getMethod_insertItem: function(config){
        var me = this;   
        return function (o) {
            var params = o.params || {},
            item = params.item,
            logErrors = params.logErrors,
            sql = me.getSql_insertItem(config, item);       
            me.callSql({
                params: {
                    sql: sql,
                    logErrors: logErrors
                },
                success: o.success,
                failure: o.failure,
                scope: o.scope
            }); 
        };
    },
    
    getSql_insertItem: function(config, item){
        var table = config.table,
            columns = table.columns,
            insertColumns = config.insertColumns || '?',
            columnName, columnConfig, value, idColumn,
            insertMaps = [],
            i, map, builder;
            
        idColumn = 'id';
        
            
        if(insertColumns === '?' || insertColumns === '*'){
            for(columnName in columns){
                if(columns.hasOwnProperty(columnName)){
                    columnConfig = columns[columnName];
                    if(columnConfig && !columnConfig.identity && !columnConfig.autoIncrement){
                        if(columnName && columnName.length){
                        value = item[columnName];       // assume property names are same as column names
                        if(insertColumns === '*' && !this.isEmpty(value)){     
                            insertMaps.push({
                                column: columnConfig,
                                value: value
                            });
                        } 
                        }
                    }
                }
            }
        }
                
        // insert 

        // build sql
        builder = [];
        builder.push('INSERT INTO `');
        builder.push(table.name);
        builder.push('` (');
        for(i=0; i<insertMaps.length; i++){
            map = insertMaps[i];
            if(i>0){
                builder.push(',');
            }
            builder.push('`');
            builder.push(map.column.name);
            builder.push('`');
        }
        builder.push(' ) VALUES ( ');      
        for(i=0; i<insertMaps.length; i++){
            map = insertMaps[i];
            if(i>0){
                builder.push(',');
            }
            builder.push(this.sqlValue(map.value, map.column.type, map.column.nullable, map.column.name));
        }
        builder.push(' );');
        
              
        return builder.join(''); 
    },
    
    
    

    // sql helpers
    requiresQuotes: function (type, name) {
        switch (type) {
        case 'int':
        case 'tinyint':
        case 'bigint':
            return false;
        case 'varchar':
        case 'datetime':
        case 'timestamp':
            return true;
        default:
            throw 'unhandled type: ' + type + ' ' + name;
        }
    },

    sqlValue: function (value, type, nullable, name) {
        var requiresQuotes;
        if(type && this.isObject(type) && !this.isDefined(nullable)){
            // passing the config
            nullable = type.nullable;
            type = type.type;
        }
        requiresQuotes = this.requiresQuotes(type, name);
        nullable = nullable === true; // defaults to false
        if (value === null || value === undefined) {
            if (nullable) {
                return 'null';
            } else {
                throw 'non nullable sql value: ' + name + ': ' + value;
            }
        } else {
            if(type === 'datetime'){
                return "'" + this.toMysqlDateTime(value) + "'";
            }else{
                if (requiresQuotes) {
                    return this.client.escape(value);
                } else {
                    return value;
                }
            }
        }
    },
    
    twoDigits: function(d) {
        if(0 <= d && d < 10) { return "0" + d.toString(); }
        if(-10 < d && d < 0) { return "-0" + (-1*d).toString(); }
        return d.toString();
    },
    toMysqlDateTime: function(dt) {
        return dt.getUTCFullYear() + "-" + this.twoDigits(1 + dt.getUTCMonth()) + "-" + 
            this.twoDigits(dt.getUTCDate()) + " " + this.twoDigits(dt.getUTCHours()) + ":" + 
            this.twoDigits(dt.getUTCMinutes()) + ":" + this.twoDigits(dt.getUTCSeconds());
    },


    // util stuff
    isDefined: function (val) {
        return Ext.isDefined(val);
    },
    isPrimitive: function (val) {
        return Ext.isPrimitive(val);
    },
    isObject: function (val) {
        return Ext.isObject(val);
    },
    isString: function (val) {
        return Ext.isString(val);
    },
    isEmpty: function (val) {
        return (val === null || !this.isDefined(val) || val === '');
    }
    
});