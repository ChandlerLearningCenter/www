/*global window, console, require*/

Ext.define('Ext.ux.app.Manager', {

    constructor: function (config) {
        config = config || {};
        this.config = config.managerConfig || config;
        this.bus = config.bus;
        this.name = config.name;
        this.checkConfig();
        this.checkSpecialtyItems();
        return this;
    },


    checkConfig: function () {
        var config = this.config,
            requiredConfigItems = this.requiredConfigItems,
            i, key, value;
        if (requiredConfigItems) {
            if (config) {
                if (Ext.isString(requiredConfigItems)) {
                    requiredConfigItems = requiredConfigItems.split(',');
                }
                if (Ext.isArray(requiredConfigItems)) {
                    for (i = 0; i < requiredConfigItems.length; i++) {
                        key = requiredConfigItems[i];
                        value = config[key];
                        if (!Ext.isDefined(value) || value === '') {
                            throw 'missing config value: ' + key;
                        }
                    }
                }
            } else {
                throw 'missing config: ' + this.name;
            }
        }
    },


    checkSpecialtyItems: function () { 
        var sm;
        if (this.stateMachineConfig) {
            if(this.stateMachineConfig.async === true){
                sm = new Ext.ux.data.StateMachineAsync(this.stateMachineConfig, this);
                this.cancelDelay = function(){ return sm.cancelDelay.apply(sm, arguments); };
            }else{
                sm = new Ext.ux.data.StateMachine(this.stateMachineConfig, this);
            }         
            this.getCurrentState = function(){ return sm.getCurrentState.apply(sm, arguments); };
            this.getNextStates = function(){ return sm.getNextStates.apply(sm, arguments); };
            this.gotoState = function(){ return sm.gotoState.apply(sm, arguments); }; 
            this.gotoNext = function(){ return sm.gotoNext.apply(sm, arguments); };
            this.stateMachine = sm;
        }
    },


    // a little helper function to make sure we are consistent.  could be another class instead
    getDefaultHealth: function () {
        return {
            module: this.name,
            isHealthy: null,
            status: null
        };
    },
    health: function (o) {
        var health = this.getDefaultHealth();
        health.isHealthy = true;
        this.handleSuccess(o, health);
    },


    getApplication: function () {
        return this.bus ? this.bus.application : null;
    },
    getManager: function (name) {
        return this.bus ? this.bus.manager[name] : null;
    },

    bind: function(fnName){
        var me, fn, tokens, i;
        if(fnName && fnName.length){ 
            if(fnName.indexOf(',') > -1){
                tokens = fnName.split(',');
                for(i=0; i<tokens.length; i++){
                    this.bind(tokens[i]);
                }
            }else{
                fn = this[fnName];
                if(!fn || !Ext.isFunction(fn)){ throw 'cannot resolve fn: ' + fnName; }
                me = this;
                this[fnName] = function(){
                    return fn.apply(me, arguments);
                };
            }
        }
    },
    
    
    evalJs: function(code){
        var evalStr = 'eval';
        window[evalStr](code);
    },
    
    log: function(){
        console.log.apply(this, arguments);  
    },
    
    keyify: function (p) {
        var k, key = [];
        // todo, this function needs some work
        //console.log('keyify: ' + Object.prototype.toString.call(p));
        if (Object.prototype.toString.call(p) === '[object Array]') {
            key.push('array:');
            key.push(p.length);
            //console.log('length = ' + p.length);
            for (k = 0; k < p.length; k++) {
                key.push(this.keyify(p[k]));
                key.push(',');
            }
        } else {
            if (Object.prototype.toString.call(p) === 'object') {
                //console.log('keyify object');
                for (k in p) {
                    if (p.hasOwnProperty(k)) {
                        //console.log(k);
                        key.push(k);
                        key.push(':');
                        key.push(String(p[k]));
                        key.push(';');
                    }
                } 
            } else {
                key.push('empty');
            }
        }      
        return key.join('');
    },

    memoizeSync: function (fnName, ttlms, keyFn) {
        // todo, preload and lock are not implemented yet.      
        var me = this,
            fn, wrapperFn, cache, callBegin, moment = require('moment'),
            useExpiredIfNeeded = true;

        //console.log('memoize: ' + fnName);
        // find the function on this object
        fn = this[fnName];
        if (!Ext.isFunction(fn)) {
            throw 'invalid function: ' + fnName;
        }

        cache = {};

        if(!keyFn){
            keyFn = this.keyify;
        }
        
        wrapperFn = function (o) {
            var params,
                key, cacheItem, nowMoment, expiredCacheItem;
                
            o = o || {};
            params = o.params;

            // get the key
            key = keyFn(params);
            //console.log(params);
            //console.log('key = ' + key);

            nowMoment = moment(new Date());

            cacheItem = cache[key];

            if (cacheItem) {
                if (nowMoment.diff(cacheItem.addedMoment, 'milliseconds') <= ttlms) {
                    // not expired
                    //console.log('use cached item: ' + key);
                    return me.handleSuccess(o, cacheItem.value);
                } else {
                    // expired
                    //console.log('expired');
                    expiredCacheItem = cacheItem;
                    cache[key] = null;
                }
            }

            // call the original function
            // but only make one call at a time.
            if (callBegin) {
                if (expiredCacheItem && useExpiredIfNeeded) {
                    return me.handleSuccess(o, expiredCacheItem.value);
                } else {
                    return me.handleFailure(o, 'data still loading');
                }
            } else {
                // make the original function call
                callBegin = new Date();
                fn.call(me, {
                    params: params,
                    success: function (data) {
                        // create a cacheItem
                        cache[key] = {
                            addedMoment: moment(new Date()),
                            value: data
                        };
                        //console.log('add to cache: ' + key);
                        callBegin = null; // no longer making the call
                        // return the data
                        me.handleSuccess(o, data);
                    },
                    failure: function (msg) {
                        callBegin = null;
                        me.handleFailure(o, msg);
                    },
                    scope: o.scope
                });
            }
        };
        // replace function with wrapped
        this[fnName] = wrapperFn;
        return true;
    }
    
    
});